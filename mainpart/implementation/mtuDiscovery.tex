\section{MTU Discovery}
\label{sec:MTU Discovery}

Die \ac{MTU} Discovery wurde in der \code{mtu} Package implementiert. Darin enthalten sind \code{analyze.go}, \code{capture.go} und \code{send.go} sowie die dazugehörigen Unit Tests.

\subsection{Öffentliche Funktionen}
Die \code{mtu} Package bietet die folgenden öffentlichen Funktionen:

\begin{itemize}
\item \textbf{Init(config config.Config, icmpPackets chan gopacket.Packet):} \\
Diese Funktion wird zur Initialisierung der \code{mtu} Package verwendet. Die Package muss zwingend vor der Verwendung der \code{FindAll()} Funktion initialisiert werden. Zur Initialisierung wird die Konfiguration sowie die der für \ac{ICMP} Pakete verwendete Go-Channel übergeben.
\item \textbf{FindAll():} \\
\code{FindAll()} sucht die \ac{MTU}s aller konfigurierten Verbindungen und meldet die Ergebnisse via der \code{logging} Package.
\item \textbf{RequestDaemonMTU(appID int, sourceIP string, destinationIP string):} \\
Die Funktion \code{RequestDaemonMTU(..)} sendet ein ICMP Request an die übergebene Destionation IP mit dem Kommando einen \ac{MTU} Discovery Vorgang zu starten. Die Funktion erwartet die AppID, Source- und Destination Adresse.
\end{itemize}

\subsection{FastMTU Algorithmus - Start Vorgang}
Der FastMTU Algorithmus ist in \code{analyze.go} implementiert. Bevor der \ac{MTU} Discovery Vorgang gestartet werden kann muss die \code{mtu} Package via der \code{mtu.init(..)} Funktion initialisiert werden. Bei der Initialisierung wird Konfiguration übergeben sowie ein Go-Channel der abgefangene \ac{ICMP} Pakete liefert (ICMP-Channel). Ausserdem wird die Funktion \code{mtu.handlePackets(..)} in einer Goroutine gestartet. Diese Funktion behandelt die über den ICMP-Channel hereinkommenden Pakete.

\begin{lstlisting}[language=go, caption=mtu.Init(..) Funktion]                    
func Init(config config.Config, icmpPackets chan gopacket.Packet) {
	conf = config
	icmpPacketsStage1 = icmpPackets
	icmpPacketsStage2 = make(chan gopacket.Packet, 100)
	initalized = true
	go handlePackets(icmpPacketsStage1, icmpPacketsStage2, conf.ApplicationID)
}
\end{lstlisting}

Nachdem die Package initialisiert ist kann der \ac{MTU} Discovery Vorgang durch einen Aufruft der \code{mtu.FindAll()} Funktion gestartet werden. Die \code{mtu.FindAll()} Funktion iteriert nun durch alle konfigurierten Tunnels und startet für jeden Tunnel eine Goroutine (\code{mtu.find(..)}), welche die spezifische Suche nach der \ac{MTU} durchführt.
Ausserdem wird noch eine Goroutine (\code{mtu.distributeMtuOkPackets(..)}) gestartet welche die Verteilung der hereinkommenden \ac{ICMP} Pakete auf die \code{mtu.find(..)}-Goroutinen übernimmt.
Danach wartet die \code{mtu.FindAll()} Funktion auf die Rückmeldungen der \code{mtu.Find(..)}-Goroutinen.

\begin{lstlisting}[language=go, caption=mtu.FindAll(..) Funktion]                    
func FindAll() {
	if !initalized { log.Println("Please init...") return }
	c := conf
	//Setup a mtuOK channel for each config
	var mtuOkChannels = make(map[int]chan int)
	for conf := range c.MTUConfList {
		mtuOkChannels[conf] = make(chan int, 100)
	}
	var quitDistribute = make(chan bool)
	go distributeMtuOkPackets(icmpPacketsStage2, mtuOkChannels, quitDistribute)

	var wg sync.WaitGroup
	for conf := range c.MTUConfList {
		logging.InfoLog("Starting MTU Disc...")
		wg.Add(1)
		go find(c.MTUConfList[conf], c.ApplicationID,
			conf, mtuOkChannels[conf], &wg)
	}
	//Wait until all MTUs have been detected
	wg.Wait()
	quitDistribute <- true
}
\end{lstlisting}

\subsection{FastMTU Algorithmus - Versenden von Requests}
In der \code{mtu.find(..)} Funktion werden zuerst einige Variablen wie \code{rangeStart}, \code{rangeEnd} etc. initialisiert. Danach wird ein for-Loop gestartet der so lange läuft bis die \ac{MTU} gefunden wurde. In diesem Loop wird dann die \code{mtu.sendBatch(..)} Funktion aufgerufen welche für einen Range die konfigurierte Anzahl \enquote{ConcurrentPackets} verschickt.

\begin{lstlisting}[language=go, caption=Ein Batch von Paketen verschicken]                    
	var results = make(map[int]bool)
	for i := rangeStart; i < (rangeEnd + itStep); i += itStep {
		sendPacket(srcIP, destIP, i, cmdMTU, appID, chanID, ICMPv4TypeEchoRequest)
		results[i] = false
	}
\end{lstlisting}

Nachdem die Pakete verschickt wurden wird auch gleich mit dem Go Timeout-Idiom auf den Ablauf des Timeouts gewartet. Dabei wird eine separate Goroutine gestartet die für die Dauer des Timeouts schläft und dann eine Nachricht in einen Channel legt. So lange das Timeout noch nicht abglaufen ist sammelt die \code{mtu.sendBatch} Funktion die Grössen aller eingefangen MTU-Discovery-Antworten ein.

\begin{lstlisting}[language=go, caption=Antworten einsammeln in mtu.sendBatch(..)]    
	timeout := make(chan bool, 1)
	go func() {
		time.Sleep(timeoutInSeconds * time.Second)
		timeout <- true
	}()

	var largestSuccessfulPacket = 0
	var gatherPackets = true
	for gatherPackets {
		select {
		case goodPacket := <-mtuOK:
			if goodPacket > largestSuccessfulPacket {
				if _, ok := results[goodPacket]; ok {
					largestSuccessfulPacket = goodPacket
					results[goodPacket] = true
				}
			}
		case <-timeout:
			gatherPackets = false
		}
	}
\end{lstlisting}

Danach wird von der \code{mtu.sendBatch(..)} Funktion die Grösse des grössten, erfolgreichen Pakets an die \code{mtu.find(..)} Funktion zurückgegeben. Die \code{mtu.find(..)} entscheidet nun ob die \ac{MTU} bereits gefunden wurde oder ob weitere Batches von Paketen versendet werden müssen.
Falls die \code{mtu.sendBatch(..)} Funktion kein sinnvolles Ergebnis (0) zurückgemeldet hat findet ein Retry statt.

Wenn die \ac{MTU} erfolgreich gefunden wurde dann wird diese von der \code{mtu.find(..)} Funktion über die \code{logging} Package an den konfigurierten Syslog Server gemeldet.

Nun wartet nur noch die \code{mtu.FindAll()} Funktion darauf dass die anderen \code{mtu.find(..)} Funktionen in ihren Goroutinen die \ac{MTU} Discovery beenden. Wenn dies geschehen ist legt die \code{mtu.FindAll()} Funktion eine Nachricht in den quit-Channel der \code{mtu.distribute- \linebreak MtuOkPackets(..)} Goroutine um diese zu schliessen. Damit ist ein vollständiger \ac{MTU} Discovery Vorgang abgeschlossen. Wie genau das Versenden von Paketen funktioniert wird nachfolgend noch etwas genauer erklärt.





\todo{Senden von Paketen spezifisch erläutern}

\subsection{ICMP Paket Payload}
Alle vom \tool{} verschickten \acs{ICMP} Pakete haben jeweils die folgende Payload:

\begin{itemize}
  \item \textbf{AppID:} Eindeutige ID des aktiven \tool{}. Wird verwendet um mehrere gleichzeitig laufende \tool{} auf einem Rechner zu unterscheiden. Die AppID wird entweder in der Konfiguration fix festgelegt oder auf 0 gesetzt. Wenn die AppID in der Konfiguration auf 0 gesetzt wurde dann wird beim Programmstart eine zufällige AppID generiert.
  \item \textbf{ChannelID:} ID des GO-Channels von dem das Paket versendet wurde. Wird benötigt um für mehrere Tunnels gleichzeitig die \acs{MTU} festzustellen zu können. Die ChannelID wird jeweils beim Start eines \acs{MTU} Discovery Vorgangs zugeteilt.
  \item \textbf{Command:} Die eigentliche Nachricht des Pakets. Wird verwendet um sicherzustellen dass dieses \acs{ICMP} Paket wirklich von einem \tool{} versendet wurde und nicht ein sonstiges \acs{ICMP} Paket.
  \item \textbf{Null-Array:} Ein mit Nullen gefülltes Array von variabler Grösse. Wird verwendet um dem Paket seine vorbestimmte Grösse zu geben.
\end{itemize}

